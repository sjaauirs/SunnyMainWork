--Script to rollback identity type from GENERATED ALWAYS to GENERATED BY DEFAULT
DO $$
DECLARE
    rec RECORD;
    is_pk BOOLEAN;
    current_identity TEXT;
BEGIN
    FOR rec IN
        SELECT 
            table_schema,
            table_name,
            column_name,
            identity_generation
        FROM information_schema.columns
        WHERE is_identity = 'YES'
        ORDER BY table_schema, table_name
    LOOP
        RAISE NOTICE 'üîç Checking %.% column % for rollback...', rec.table_schema, rec.table_name, rec.column_name;

        -- Check if column is part of the PRIMARY KEY
        SELECT EXISTS (
            SELECT 1
            FROM information_schema.table_constraints tc
            JOIN information_schema.key_column_usage kcu
              ON tc.constraint_name = kcu.constraint_name
             AND tc.table_schema = kcu.table_schema
             AND tc.table_name = kcu.table_name
            WHERE 
                tc.constraint_type = 'PRIMARY KEY'
                AND kcu.table_schema = rec.table_schema
                AND kcu.table_name = rec.table_name
                AND kcu.column_name = rec.column_name
        ) INTO is_pk;

        -- Only process if column is PK and identity is GENERATED ALWAYS
        IF is_pk AND rec.identity_generation = 'ALWAYS' THEN
            RAISE NOTICE '‚Ü©Ô∏è Reverting %.%.% from GENERATED ALWAYS to BY DEFAULT...', rec.table_schema, rec.table_name, rec.column_name;

            EXECUTE format(
                'ALTER TABLE %I.%I ALTER COLUMN %I DROP IDENTITY IF EXISTS',
                rec.table_schema, rec.table_name, rec.column_name
            );

            EXECUTE format(
                'ALTER TABLE %I.%I ALTER COLUMN %I ADD GENERATED BY DEFAULT AS IDENTITY',
                rec.table_schema, rec.table_name, rec.column_name
            );

            RAISE NOTICE '‚úÖ Reverted %.%.% to GENERATED BY DEFAULT.', rec.table_schema, rec.table_name, rec.column_name;

        ELSIF is_pk THEN
            RAISE NOTICE '‚ö†Ô∏è %.%.% is already GENERATED BY DEFAULT. No action taken.', rec.table_schema, rec.table_name, rec.column_name;
        ELSE
            RAISE NOTICE '‚è≠Ô∏è %.%.% is not a primary key column. Skipping.', rec.table_schema, rec.table_name, rec.column_name;
        END IF;
    END LOOP;
END
$$;

--Script to set the sequence to max identity value.
DO $$
DECLARE
    rec RECORD;
    _max BIGINT;
    _seq TEXT;
BEGIN
    FOR rec IN
        SELECT table_schema, table_name, column_name
        FROM information_schema.columns
        WHERE identity_generation IS NOT NULL
        ORDER BY table_schema, table_name
    LOOP
        RAISE NOTICE 'üîç Checking table %.%, column %', rec.table_schema, rec.table_name, rec.column_name;

        -- Get the sequence name dynamically
        EXECUTE format(
            'SELECT pg_get_serial_sequence(%L, %L)',
            rec.table_schema || '.' || rec.table_name,
            rec.column_name
        ) INTO _seq;

        IF _seq IS NULL THEN
            RAISE NOTICE '‚ùå No sequence found for %.% column %', rec.table_schema, rec.table_name, rec.column_name;
            CONTINUE;
        END IF;

        -- Get the current MAX value in the table's identity column
        EXECUTE format(
            'SELECT MAX(%I) FROM %I.%I',
            rec.column_name, rec.table_schema, rec.table_name
        ) INTO _max;

        IF _max IS NULL THEN
            RAISE NOTICE '‚ö†Ô∏è Table %.% has no rows. Sequence % not updated.', rec.table_schema, rec.table_name, _seq;
            CONTINUE;
        END IF;

        -- Set sequence to the max value
        EXECUTE format(
            'SELECT setval(%L, %s, true)',
            _seq, _max
        );

        RAISE NOTICE '‚úÖ Sequence % set to % for %.% column %', _seq, _max, rec.table_schema, rec.table_name, rec.column_name;
    END LOOP;
END$$;
